<!DOCTYPE html>
<meta charset="utf-8">

<head>
<script src="./samples.js" type="text/javascript"></script>
<script src="./VehicleSimulation.js" type="text/javascript"></script>
<script src="./d3js.org_d3.v4.js" type="text/javascript"></script>
<script>

/** We create the user inputs via a dict, since
    there are so many of them.
 */

// import {VehicleSimulation} from './VehicleSimulation.js';
var vehicleSimulation = new VehicleSimulation();

// -- the following lists are displayed as values in the graph:
// list: [attribute name from VehicleSimulation, color name, scale factor, data]
const displayValues = [
  ['currentThrottleFaded', 'Navy', 0.2, []],
  ['selectedAutomaticGear', 'CadetBlue', 25.0, []],
  ['overdrive', 'Chocolate', 100.0, []],
  ['engineOn', 'Crimson', 95.0, []],
  ['engineRunning', 'MediumPurple', 90.0, []],
  ['driveState', 'Olive', 11.0, []],
  ['engineState', 'OliveDrab', 10.0, []],
  ['engineLoad', 'DarkSalmon', 0.2, []],
  ['currentRpm', 'DarkSlateGrey', 0.2, []],
  ['currentSpeed', 'DeepPink', 0.2, []],
  ['escPulseWidth', 'HotPink', 0.05, []]
]

// -- the following lists are created as input elements:

// values from vehicles.h
const vehicleValues = [
  ['TRACKED_MODE', false, 0, 0],
  ['AIRPLANE_MODE', false, 0, 0],
  ['EXCAVATOR_MODE', false, 0, 0],
  ['STEAM_LOCOMOTIVE_MODE', false, 0, 0],
  ['SUPER_SLOW', false, 0, 0],

  ['startVolumePercentage', 120, 0, 200],
  ['idleVolumePercentage', 72, 0, 200],
  ['engineIdleVolumePercentage', 60, 0, 200],
  ['fullThrottleVolumePercentage', 130, 0, 200],
  ['revVolumePercentage', 80, 0, 200],
  ['engineRevVolumePercentage', 60, 0, 200],

  ['REV_SOUND', true, 0, 0],
  ['revSwitchPoint', 10, 0, 200],
  ['idleEndPoint', 500, 0, 1000],
  ['idleVolumeProportionPercentage', 90, 0, 200],

  ['JAKEBRAKE_ENGINE_SLOWDOWN', true, 0, 0],
  ['JAKE_BRAKE_SOUND', true, 0, 0],
  ['dieselKnockVolumePercentage', 40, 0, 200],
  ['dieselKnockIdleVolumePercentage', 0, 0, 200],
  ['dieselKnockStartPoint', 10, 0, 1000],
  ['dieselKnockInterval', 8, 0, 20],

  ['V8', true, 0, 0],
  ['dieselKnockAdaptiveVolumePercentage', 18, 0, 200],

  ['RPM_DEPENDENT_KNOCK', true, 0, 200],
  ['minKnockVolumePercentage', 80, 0, 200],
  ['knockStartRpm', 50, 0, 200],

  ['turboVolumePercentage', 5, 0, 200],
  ['turboIdleVolumePercentage', 0, 0, 200],
  ['chargerVolumePercentage', 0, 0, 200],
  ['chargerIdleVolumePercentage', 10, 0, 200],
  ['chargerStartPoint', 10, 0, 200],

  ['wastegateVolumePercentage', 18, 0, 200],
  ['wastegateIdleVolumePercentage', 1, 0, 200],

  ['fanVolumePercentage', 0, 0, 200],
  ['fanIdleVolumePercentage', 0, 0, 200],
  ['fanStartPoint', 0, 0, 200],

  ['hornVolumePercentage', 80, 0, 200],
  ['sirenVolumePercentage', 80, 0, 200],

  ['brakeVolumePercentage', 30, 0, 200],
  ['parkingBrakeVolumePercentage', 30, 0, 200],
  ['shiftingVolumePercentage', 40, 0, 200],
  ['sound1VolumePercentage', 100, 0, 200],

  ['reversingVolumePercentage', 14, 0, 200],

  ['indicatorVolumePercentage', 10, 0, 200],

  ['escRampTimeFirstGear', 20, 0, 200],
  ['escRampTimeSecondGear', 50, 0, 200],
  ['escRampTimeThirdGear', 75, 0, 200],
  ['escBrakeSteps', 30, 0, 200],
  ['escAccelerationSteps', 3, 0, 200],

  ['automatic', false, 0, 0],
  ['doubleClutch', false, 0, 0],
  ['shiftingAutoThrottle', true, 0, 0],
  ['clutchEngagingPoint', 90, 0, 200],

  ['MAX_RPM_PERCENTAGE', 330, 0, 1000],

  ['acc', 2, 1, 20],
  ['dec', 1, 1, 20],
];

// -- defines in 2_remotes.h
const remoteValues = [
  ['AUTO_ENGINE_ON_OFF', true, 0, 200],
  ['AUTO_LIGHTS', true, 0, 200],
];

// -- defines in 4_transmission.h
const transmissionValues = [
  ['OVERDRIVE', false, 0, 0],
  ['VIRTUAL_3_SPEED', false, 0, 0],
  ['VIRTUAL_16_SPEED_SEQUENTIAL', false, 0, 0],
  ['automaticReverseAccelerationPercentage', 100, 0, 200],
  ['lowRangePercentage', 58, 0, 200],
  ['SEMI_AUTOMATIC', false, 0, 0],
  ['TRANSMISSION_NEUTRAL', true, 0, 0],
  ['maxClutchSlippingRpm', 250, 0, 400],
  ['DOUBLE_CLUTCH', false, 0, 0],
  ['HIGH_SLIPPINGPOINT', false, 0, 0]
];


const valueOnchangeFunction = function() {
  // I get the name of the attribute from the input ID.
  // e.g. input_AUTO_LIGHTS
  const name = this.id.slice("input_".length);
  if ((typeof vehicleSimulation[name]) == "boolean") {
    vehicleSimulation[name] = this.checked;
  } else {
    vehicleSimulation[name] = Number(this.value);
  }
}

/** Adds an input element plus label plus table row to the parent element.
 *
 *  @param defs An array of "name", default value, minimum, maximum value
 */
function addInputTr(defs, parentElement) {

  let elTr = document.createElement('tr');

  const id = "input_" + defs[0];
  let elLabel = document.createElement('label');
  elLabel.setAttribute("for", id);
  elLabel.textContent = defs[0] + ":";
  let elTd = document.createElement('td');
  elTd.appendChild(elLabel);
  elTr.appendChild(elTd);

  let elInput = document.createElement('input');
  elInput.id = id;
  if ((typeof defs[1]) == "boolean") {
    elInput.type = 'checkbox';
    elInput.checked = defs[1];
  } else if ((typeof defs[1]) == "number") {
    elInput.type = 'number';
    elInput.min = defs[2];
    elInput.max = defs[3];
    elInput.value = defs[1];
  }
  elInput.onchange = valueOnchangeFunction;
  elTd = document.createElement('td');
  elTd.appendChild(elInput);
  elTr.appendChild(elTd);


  parentElement.appendChild(elTr);
}


/** Adds all input elements from the defs array
 *
 *  @param defs An array of an array with the values used by addInput()
 */
function addInputs(defss, parentElement) {
  for (let i = 0; i < defss.length; i++) {
    addInputTr(defss[i], parentElement);
  }
}

/** Decodes a .h file and returns a buffer.
 *
 *  @returns An array with sample rate and the buffer data.
 */
function headerToArray(headerText) {

  const headerLines = headerText.split("\n");

  // -- find the sample rate:
  const srRe = /samplerate\s*=\s*(\d+)\s*;/i;
  let sampleRate = 22050;
  for (let i = 0; i < headerLines.length; i++) {
    let results = srRe.exec(headerLines[i]);
    if (results !== null) {
      sampleRate = parseInt(sampleRate)
      break;
    }
  }

  // -- find the samples (we assume it_s a line with commas
  let buffer = [];
  for (let i = 0; i < headerLines.length; i++) {
    let numbers = headerLines[i].split(",");
    if (numbers.length > 1) {
      // ignore everything after the last comma
      // might be a comment or a closing }
      for (let j = 0; j < numbers.length - 1; j++) {
          buffer.push(parseInt(numbers[j]) / 128.0);
      }
    }
  }

  return [sampleRate, buffer];
}

/** Adds an unsigned 8 bit value to the given byte buffer
 *  at the given position.
 */
function addInt8(pos, buffer, value) {
  buffer[pos] = value & 0xff;
}


/** Adds an unsigned 16 bit value to the given byte buffer
 *  at the given position.
 *
 *  It's little endian.
 */
function addInt16(pos, buffer, value) {
  addInt8(pos,     buffer, value);
  addInt8(pos + 1, buffer, value >> 8);
}


/** Adds an unsigned 32 bit value to the given byte buffer
 *  at the given position.
 *
 *  It's little endian.
 */
function addInt32(pos, buffer, value) {
  addInt16(pos,     buffer, value);
  addInt16(pos + 2, buffer, value >> 16);
}


/** Converts the given text (header/include) file to a wav array.
 *
 *  @param repeats: The number of times the audio sample is
 *     repeated (put one after another).
 */
function toWav(headerText, repeats=1) {

  const [sampleRate, buffer] = headerToArray(headerText);

  const bytesNo = 1;  // number of bytes per sample
  const channels = 1;
  const samplesNo = buffer.length * repeats;
  const fileLength = samplesNo * bytesNo + 44;
  
  var buf = new Int8Array(fileLength);

  // -- RIFF section
  addInt8(0, buf, "R".charCodeAt(0));
  addInt8(1, buf, "I".charCodeAt(0));
  addInt8(2, buf, "F".charCodeAt(0));
  addInt8(3, buf, "F".charCodeAt(0));
  addInt32(4, buf, fileLength - 8)

  // -- format section
  addInt8(8,  buf, "W".charCodeAt(0));
  addInt8(9,  buf, "A".charCodeAt(0));
  addInt8(10, buf, "V".charCodeAt(0));
  addInt8(11, buf, "E".charCodeAt(0));

  addInt8(12, buf, "f".charCodeAt(0));
  addInt8(13, buf, "m".charCodeAt(0));
  addInt8(14, buf, "t".charCodeAt(0));
  addInt8(15, buf, " ".charCodeAt(0));

  addInt32(16, buf, 16); // format section length
  addInt16(20, buf, 1);  // format type (PCM)
  addInt16(22, buf, channels); // format type (PCM)
  addInt32(24, buf, sampleRate);

  const bitRate = bytesNo * channels * sampleRate;
  addInt32(28, buf, bitRate);
  addInt16(32, buf, bytesNo * channels);
  addInt16(34, buf, bytesNo * 8);
  
  // -- data section
  addInt8(36, buf, "d".charCodeAt(0));
  addInt8(37, buf, "a".charCodeAt(0));
  addInt8(38, buf, "t".charCodeAt(0));
  addInt8(39, buf, "a".charCodeAt(0));

  const dataSectionLength = bytesNo * samplesNo;
  addInt32(40, buf, dataSectionLength); // data section length
  let pos = 44;
  for (let j = 0; j < repeats; j++) {
    for (let i = 0; i < buffer.length; i++) {
      if (bytesNo == 1) {
        addInt8(pos, buf, Math.round(buffer[i] * (1 << 7) + (1 << 7)));
        pos++;
      } else if (bytesNo == 2) {
        addInt16(pos, buf, Math.round(buffer[i] * (1 << 15)));
        pos+=2;
      } else if (bytesNo == 4) {
        addInt32(pos, buf, Math.round(buffer[i] * (1 << 31)));
        pos+=4;
      }
    }
  }

  return buf;
}


/** Called when the header file is loaded.
 *
 *  Converts the input file an set's the src of the audio element,
 *  so that it be played back.
 */
function headerFileLoaded(loaded) {

  const repeats = document.querySelector('#input_repeats').value;
  const blob = new Blob(
    [toWav(loaded.target.result, repeats)],
    {type:'audio/wav'});
  const URLObject = window.webkitURL || window.URL;
  const url = URLObject.createObjectURL(blob);

  let audio_source = document.querySelector('#audio_source');
  audio_source.src = url;

  document.querySelector('#audio_download').href=url;

  let audio_control = document.querySelector('#audio_control');
  audio_control.pause();
  audio_control.load();
  audio_control.oncanplaythrough = audio_control.play();
}


/** Starts downloading and then converting the given file.
 */
function newFileSelected(event)
{
  let fr = new FileReader();
  // fr.inputFileName = event.target.files[0];
  fr.onload = headerFileLoaded;  // onload fires after reading is complete
  fr.readAsText(event.target.files[0]);
}


function updateMassSimulation()
{
  vehicleSimulation.step(1000);
  vehicleSimulation.mapThrottle();
  vehicleSimulation.engineMassSimulation();
  // vehicleSimulation.automaticGearSelector();
  vehicleSimulation.engineOnOff();
  vehicleSimulation.gearboxDetection();
  vehicleSimulation.esc();
  vehicleSimulation.variablePlaybackTimer();
}

function addGraph(parentElement)
{
  // set the dimensions and margins of the graph
  const margin = {top: 10, right: 30, bottom: 30, left: 60};
  const width = d3.select(parentElement).node().getBoundingClientRect().width
    - margin.left - margin.right
  // const width = 460 - margin.left - margin.right;
  const height = 400 - margin.top - margin.bottom;

  // append the svg object to the body of the page
  var svg = d3.select(parentElement)
    .append("svg")
      .attr("width", width + margin.left + margin.right)
      .attr("height", height + margin.top + margin.bottom)
    .append("g")
      .attr("transform",
            "translate(" + margin.left + "," + margin.top + ")");
  svg.id = "graph";

  let x = d3.scaleLinear()
    .domain([0, 100])
    .range([-5, width]); // starting point is -5 so the first value doesn't show and slides off the edge as part of the transition
  svg.append("g")
    .attr("transform", "translate(0," + height + ")")
    .call(d3.axisBottom(x));

  var y = d3.scaleLinear()
    .domain([100, 0])
    .range([0, height]);
  svg.append("g")
    .call(d3.axisLeft(y));

  let line = d3.line()
    .x(function(d, i) { return x(i) })
    .y(function(d) { return y(d) });

  // -- add the line graphs
  for (let i = 0; i < displayValues.length; i++) {
    let values = displayValues[i];
    svg
      .append("path")
      .attr("id", "graph" + values[0])
      .datum(values[3])
      .attr("fill", "none")
      .attr("stroke", values[1])
      .attr("stroke-width", 1.5)
      .attr("d", line);
  }

  // -- add a legend
  const size = 10
  svg.selectAll("legendDots")
    .data(displayValues)
    .enter()
    .append("rect")
      .attr("x", 50)
      .attr("y", function(d,i){ return 20 + i*(size+5)}) // 100 is where the first dot appears. 25 is the distance between dots
      .attr("width", size)
      .attr("height", size)
      .style("fill", function(d){ return d[1]})

  svg.selectAll("legendLabels")
    .data(displayValues)
    .enter()
    .append("text")
      .attr("x", 50 + size*1.2)
      .attr("y", function(d,i){ return 20 + i*(size+5) + (size/2)}) // 100 is where the first dot appears. 25 is the distance between dots
      .style("fill", function(d){ return d[1]})
      .text(function(d){ return d[0]})
      .attr("text-anchor", "left")
      .style("alignment-baseline", "middle")

  function redraw() {
    for (let i = 0; i < displayValues.length; i++) {
      let values = displayValues[i];
      let data = values[3];
      if (data.length > 100) {
        data.shift();
      }
      data.push(vehicleSimulation[values[0]] * values[2]);
      svg.select("#graph" + values[0])
        .data([data]) // set the new data
        .attr("d", line); // apply the new data values
    }
  }

  setInterval(function() {
     redraw();
  }, 100);
}

</script>

<style>
	body {
    font-family: arial;
	}
  legend {
    background-color: #000;
    color: #fff;
    padding: 3px 6px;
  }
  fieldset {
    width: fit-content;
	  background-color: #eee;
  }
  fieldset label {
    width: 20em;
  }
  tr:nth-child(even) {background-color: #ddd;}
  td { vertical-align: top; }

  #graphDiv {
    width: 1000px;
  }
</style>

</head>

<body>
  <h3>RC Engine Sound simulation</h3>
  <table>
    <tr>
      <td rowspan="2">
        <fieldset>
          <legend>Values from vehicle.h</legend>
          <table id="inputTableVehicle">
          </table>
        </fieldset>
      </td>
      <td rowspan="2">
        <fieldset>
          <legend>Values from transmission.h</legend>
          <table id="inputTableTransmission">
          </table>
        </fieldset>
      </td>
      <td style="height: 1px;">
        <label for="inputThrottle">throttle:</label>
        <input type="range" id="inputThrottle" min="1000" max="2000" value="1500"
           onchange="vehicleSimulation.pulseWidth = this.value"/>
        <br/>
        <label for="inputGear">gear:</label>
        <input type="range" id="inputGear" min="1" max="16" value="1"
           onchange="vehicleSimulation.selectedGear = this.value"/>
        <br/>
      </td>
    </tr>
    <tr>
      <td>
        <div id="graphDiv"></div>
      </td>
    </tr>
  </table>
  <small>
    Ralf Engels for <a href="https://github.com/TheDIYGuy999/Rc_Engine_Sound_ESP32">ESP32 RC Engine Sound & Light Controller</a>
  </small>

  <script type="module">
    addInputs(vehicleValues,
       document.querySelector('#inputTableVehicle'));
    addInputs(transmissionValues,
       document.querySelector('#inputTableTransmission'));
    addGraph(
       document.querySelector('#graphDiv'));
    const massSimulationInterval = setInterval(updateMassSimulation, 100);
  </script>
</body>

</html>
