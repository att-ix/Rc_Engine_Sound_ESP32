<head>
<script>
"use strict";

// note: the surprising behaviour of the AudioContext.
// The reported sample rate is not the one from the file.
// See: https://stackoverflow.com/questions/34201957/why-are-decodeaudiodata-results-different-on-different-os
window.AudioContext = window.AudioContext || window.webkitAudioContext;
var context = new AudioContext();

/** Class for keeping track of an audio block.
 *
 *  This is a segment from the original audio buffer
 *  with start, end, volume and RMP information.
 */
class AudioBlock {
  buffer = null; ///< float 32 array (-1..1) with full audio data
  sampleStart = 0; ///< start sample in the audio buffer of this block
  sampleEnd = 0; ///< end sample in the audio buffer of this block
  sampleRate = 0; ///< Samples per second of the buffer data

  constructor(buffer, sampleStart, sampleEnd, sampleRate) {
    this.buffer = buffer;
    this.sampleStart = sampleStart;
    this.sampleEnd = sampleEnd;
    this.sampleRate = sampleRate;
  }

  /// float with the max difference between the audio samples
  get volume() {
    let minValue = 0;
    let maxValue = 0;
    for (let j = this.sampleStart; j < this.sampleEnd; j++) {
      maxValue = Math.max(maxValue, this.buffer[j]);
      minValue = Math.min(minValue, this.buffer[j]);
    }
    return maxValue - minValue;
  }

  /// rpm in this audio block.
  get rpm() {
    return 60.0 * this.sampleRate / (this.sampleEnd - this.sampleStart);
  }
}

/** Class for handling an EngineRampSound.
 *
 *  It can analyze an engine sound and extract
 *  sample pieces to be used to synthesize
 *  engine sound later on from those samples.
 */
class EngineRampSound {

  buffer = []; ///< float 32 array (-1..1) with full audio data
  noCylinders = 0; ///< number of cylinders
  sampleRate = 0; ///< Samples per second of the buffer data

  blocks = []; ///< an array of AudioBlock objects

  rpmMin = 1000; ///< min rpm used for sound blocks
  rpmMax = 2000; ///< max rpm used for sound blocks
  rpmStep = 5;

  /** An array of block objects, for the range of RPMs */
  accelBlocks = new Array(Math.ceil((this.rpmMax - this.rpmMin) / this.rpmStep));

  /** An array of block objects, for the range of RPMs */
  deccelBlocks = new Array(Math.ceil((this.rpmMax - this.rpmMin) / this.rpmStep));

  /** Constructs an EngineRampSound
   *
   *  @param audioBuffer An AudioBuffer object with the audio input.
   *  @param noCylinders The number of cylinders in the engine.
   */
  constructor(audioBuffer, noCylinders) {
    this.buffer = audioBuffer.getChannelData(0);
    // -- convert to mono if not already
    if (audioBuffer.numberOfChannels > 1) {
      for(let c = 1; c < audioBuffer.numberOfChannels; c++) {
        const cb = audioBuffer.getChannelData(c);
        for(let i = 0; i < cp.length; i++) {
          this.buffer[i] += cb[i];
        }
      }
    }

    this.noCylinders = noCylinders;
    this.sampleRate = audioBuffer.length / audioBuffer.duration;

    // split up the audio into blocks
    const positions = keepNthPositions(
      cleanUpPositions(
        zeroCrossings(
          filterLowpass(this.buffer, 20)), 100),
      noCylinders);

    this.blocks = [];
    for (let i = 0; i < positions.length - 1; i++) {
      this.blocks.push(new AudioBlock(
        this.buffer, positions[i], positions[i+1], this.sampleRate));
    }

    // pick suitable accel and deccel blocks
    for (let i = 0; i < this.blocks.length; i++) {
      const rpm = this.blocks[i].rpm;
      const pos = Math.round((rpm - this.rpmMin) / this.rpmStep);
      if ((pos < 0) || pos >= this.accelBlocks.length) {
        continue;
      }

      // see if this is an accel or deccel block by looking
      // at the rpms of the neighbouring blocks
      let rpmPrev = rpm;
      if (i > 0) {
        rpmPrev = this.blocks[i - 1].rpm;
      }
      let rpmNext = rpm;
      if (i < this.blocks.length - 1) {
        rpmNext = this.blocks[i + 1].rpm;
      }

      if ((rpmPrev <= rpm) && (rpm < rpmNext)) {
        this.accelBlocks[pos] = i;
      } else if ((rpmPrev >= rpm) && (rpm > rpmNext)) {
        this.deccelBlocks[pos] = i;
      } else {
        // ignore this block
      }
    }
  }
};


/** Decodes a .h file and returns a buffer.
 *
 *  @returns An array with sample rate and the buffer data.
 */
function headerToArray(headerText) {

  const headerLines = headerText.split("\n");

  // -- find the sample rate:
  const srRe = /samplerate\s*=\s*(\d+)\s*;/i;
  let sampleRate = 22050;
  for (let i = 0; i < headerLines.length; i++) {
    let results = srRe.exec(headerLines[i]);
    if (results !== null) {
      sampleRate = parseInt(sampleRate)
      break;
    }
  }

  // -- find the samples (we assume it_s a line with commas
  let buffer = [];
  for (let i = 0; i < headerLines.length; i++) {
    let numbers = headerLines[i].split(",");
    if (numbers.length > 1) {
      // ignore everything after the last comma
      // might be a comment or a closing }
      for (let j = 0; j < numbers.length - 1; j++) {
          buffer.push(parseInt(numbers[j]) / 128.0);
      }
    }
  }

  return [sampleRate, buffer];
}


/** Converts the given text (header/include) file to a wav array.
 *
 *  @param repeats: The number of times the audio sample is
 *     repeated (put one after another).
 *  @returns An Int8Array with the wav data.
 */
function toWav(buffer, sampleRate, repeats=1) {

  const bytesNo = 1;  // number of bytes per sample
  const channels = 1;
  const samplesNo = buffer.length * repeats;
  const fileLength = samplesNo * bytesNo + 44;
  
  const buf = new ArrayBuffer(fileLength);
  const view = new DataView(buf, 0)

  // -- RIFF section
  view.setUint8(0, "R".charCodeAt(0));
  view.setUint8(1, "I".charCodeAt(0));
  view.setUint8(2, "F".charCodeAt(0));
  view.setUint8(3, "F".charCodeAt(0));
  view.setUint32(4, fileLength - 8, true)

  // -- format section
  view.setUint8(8, "W".charCodeAt(0));
  view.setUint8(9, "A".charCodeAt(0));
  view.setUint8(10, "V".charCodeAt(0));
  view.setUint8(11, "E".charCodeAt(0));

  view.setUint8(12, "f".charCodeAt(0));
  view.setUint8(13, "m".charCodeAt(0));
  view.setUint8(14, "t".charCodeAt(0));
  view.setUint8(15, " ".charCodeAt(0));

  view.setUint32(16, 16, true); // format section length
  view.setUint16(20, 1, true);  // format type (PCM)
  view.setUint16(22, channels, true); // format type (PCM)
  view.setUint32(24, sampleRate, true);

  const bitRate = bytesNo * channels * sampleRate;
  view.setUint32(28, bitRate, true);
  view.setUint16(32, bytesNo * channels, true);
  view.setUint16(34, bytesNo * 8, true);
  
  // -- data section
  view.setUint8(36, "d".charCodeAt(0));
  view.setUint8(37, "a".charCodeAt(0));
  view.setUint8(38, "t".charCodeAt(0));
  view.setUint8(39, "a".charCodeAt(0));

  const dataSectionLength = bytesNo * samplesNo;
  view.setUint32(40, dataSectionLength, true); // data section length
  let pos = 44;
  for (let j = 0; j < repeats; j++) {
    for (let i = 0; i < buffer.length; i++) {
      if (bytesNo == 1) {
        view.setUint8(pos, Math.round(buffer[i] * (1 << 7) + (1 << 7)));
        pos++;
      } else if (bytesNo == 2) {
        view.setUint16(pos, Math.round(buffer[i] * (1 << 15)), true);
        pos+=2;
      } else if (bytesNo == 4) {
        view.setUint32(pos, Math.round(buffer[i] * (1 << 31)), true);
        pos+=4;
      }
    }
  }

  return new Uint8Array(buf);
}


/** Starts downloading and then converting the given file.
 */
function newFileSelected(event)
{
  let fr = new FileReader();
  // fr.inputFileName = event.target.files[0];
  fr.onload = headerFileLoaded;  // onload fires after reading is complete
  fr.readAsText(event.target.files[0]);
}

function sqr(x) { return x * x; }

/** Returns an array with the normal distribution.
 */
function normDistribution(omega) {

  const halfWidth = omega * 2;
  const width = omega * 4 + 1;

  let buffer = new Float32Array(width);
  for (let i = 0; i < width; i++ ) {
    buffer[i] = (1.0 / Math.sqrt(2.0 * Math.PI * sqr(omega))) *
      Math.exp(-0.5 * sqr((i - halfWidth) / omega))
  }

  return buffer;
}


/** Applys a convolution low pass filter to the input buffer.
 *
 *  @param bufferIn An array with the audio samples.
 *  @param omega The width of the norm distribution used as filter.
 */
function filterLowpass(bufferIn, omega=5) {
  const filter = normDistribution(omega)

  let bufferOut = new Float32Array(bufferIn.length);
  for (let i = 0; i < bufferOut.length; i++) {
    bufferOut[i] = 0.0;
  }

  for (let i = 0; i < bufferIn.length; i++) {
    for (let j = 0; j < filter.length; j++) {
      let iI = i + j - Math.ceil(filter.length / 2);
      if (iI < 0) {
        iI = 0;
      } if (iI >= bufferIn.length) {
        iI = bufferIn.length - 1;
      }
      bufferOut[i] += bufferIn[iI] * filter[j];
    }
  }

  return bufferOut;
}


/** Returns an array of the positions in the input buffer
 *  where the values go from negative to positive.
 *
 *  @param bufferIn An array with the audio samples.
 */
function zeroCrossings(bufferIn) {
  let positions = [0];
  for (let i = 1; i < bufferIn.length; i++) {
    if (bufferIn[i - 1] < 0 && bufferIn[i] >= 0) {
      positions.push(i);
    }
  }
  positions.push(bufferIn.length - 1);

  return positions;
}


/** Returns an array of the positions in the input buffer
 *  where the first derivative changes it's sign
 *
 *  @param bufferIn An array with the audio samples.
 */
function localMinima(bufferIn) {
  let positions = [0];
  for (let i = 1; i < bufferIn.length - 1; i++) {
    const diff1 = bufferIn[i - 1] - bufferIn[i];
    const diff2 = bufferIn[i] - bufferIn[i + 1];
    if (diff1 < 0 && diff2 >= 0) {
      positions.push(i);
    }
  }
  positions.push(bufferIn.length - 1);

  return positions;
}


/** Cleans up the positions.
 *
 *  Since we can't split too large blocks, we
 *  are merging blocks that are below minimum
 *  length.
 *
 *  Keeps the first and the last position.
 *
 *  @param positionsIn An array of positions. Sorted ascending. Must have at least one position
 *  @param minDist The minimum difference between the positions
 */
function cleanUpPositions(positionsIn, minDist) {
  let positionsOut = [positionsIn[0]];

  for (let i = 1; i < positionsIn.length - 1; i++) {
    if (positionsIn[i] - positionsOut[positionsOut.length - 1] >= minDist) {
      positionsOut.push(positionsIn[i]);
    }
  }

  positionsOut.push(positionsIn[positionsIn.length - 1])
  return positionsOut;
}


/** Keep only evere n-th position.
 *
 *  Keeps the first and the last position.
 *
 *  @param positionsIn An array of positions. Sorted ascending.
 *  @param nth
 */
function keepNthPositions(positionsIn, nth) {
  let positionsOut = [];

  for (let i = 0; i < positionsIn.length - 2; i += nth) {
    positionsOut.push(positionsIn[i]);
  }

  positionsOut.push(positionsIn[positionsIn.length - 1])
  return positionsOut;
}


/** Calculates the volume of the blocks.
 */
function calcVolumeBlock(positions, buffer) {
  let volumes = [];

  for (let i = 0; i < positions.length - 1; i++) {
    let minValue = 0;
    let maxValue = 0;
    for (let j = positions[i]; j < positions[i + 1]; j++) {
      maxValue = Math.max(maxValue, buffer[j]);
      minValue = Math.min(minValue, buffer[j]);
    }
    volumes.push(maxValue - minValue);
  }

  return volumes;
}


/** Calculates the rpms of the blocks.
 */
function calcRpmBlock(positions, samplerate) {
  let rpms = [];

  for (let i = 1; i < positions.length; i++) {
    const rpm = 60.0 * samplerate / (positions[i] - positions[i-1]);
    rpms.push(rpm);
  }

  return rpms;
}


function addBlock(buffer, positions, block, reverse, newBuffer) {
  if (block < 0) {
    block = 0;
  }
  if (block >= positions.length - 1) {
    block = positions.length - 2;
  }

  if (reverse) {
  for (let j = positions[block + 1] - 1; j >= positions[block]; j--) {
      newBuffer.push(buffer[j]);
    }
  } else {
    for (let j = positions[block]; j < positions[block + 1]; j++) {
      newBuffer.push(buffer[j]);
    }
  }
}

function processAudio(audioBuffer)
{
  // float 32 array (-1..1)
	let buffer = audioBuffer.getChannelData(0);
  const origSampleRate = audioBuffer.length / audioBuffer.duration;

  // -- convert to mono if not already
	if (audioBuffer.numberOfChannels > 1)
	{
		for(let c = 1; c < audioBuffer.numberOfChannels; c++)
		{
			const cb = audioBuffer.getChannelData(c);
			for(let i = 0; i < cp.length; i++)
				buffer[i] += cb[i];
		}
	}

  // buffer = filterLowpass(buffer);

  const positions = keepNthPositions(cleanUpPositions(zeroCrossings(filterLowpass(buffer, 5)), 100), 10);
  
  let diffs = [];
  for (let i = 0; i < positions.length - 1; i++) {
    diffs.push(positions[i+1] - positions[i]);
  }

  // new buffer by skipping every second position
  let newBuffer = [];
  /*
  for (let i = 0; i < positions.length - 1; i++) {
    addBlock(buffer, positions, i, false, newBuffer);
    addBlock(buffer, positions, i, false, newBuffer);
  }
  */
  for (let i = positions.length - 2; i >=0; i-=3) {
    addBlock(buffer, positions, i, false, newBuffer);
  }
  for (let j = 0; j < 10; j++) {
    for (let i = 1; i < 8; i++) {
      addBlock(buffer, positions, i, false, newBuffer);
      addBlock(buffer, positions, i, false, newBuffer);
      addBlock(buffer, positions, i, false, newBuffer);
    }
    for (let i = 7; i >=1; i--) {
      addBlock(buffer, positions, i, false, newBuffer);
      addBlock(buffer, positions, i, false, newBuffer);
      addBlock(buffer, positions, i, false, newBuffer);
    }
  }

  const blob = new Blob(
    [toWav(
        newBuffer,
        origSampleRate,
        1)],
    {type:'audio/wav'});
  const URLObject = window.webkitURL || window.URL;
  const url = URLObject.createObjectURL(blob);

  let audio_source = document.querySelector('#audio_source');
  audio_source.src = url;

  document.querySelector('#audio_download').href=url;

  let audio_control = document.querySelector('#audio_control');
  audio_control.pause();
  audio_control.load();
  audio_control.oncanplaythrough = audio_control.play();
}


function processFile(event)
{
	let audioBuffer = null;
	let reader = new FileReader();
	let file = event.target.files[0];
	reader.onload = function(){
    context.decodeAudioData(reader.result, function(buffer) {
      processAudio(buffer);
		}, function(){
			// error
		});
	}
	reader.readAsArrayBuffer(file);	
}


function analyzeAudio(audioBuffer, noCylinders)
{
  const engineRampSound = new EngineRampSound(audioBuffer, noCylinders);
  
  const volumes   = engineRampSound.blocks.map((x) => x.volume);
  const maxVolume = Math.max(...volumes);
  const minVolume = Math.min(...volumes);
  const rpms      = engineRampSound.blocks.map((x) => x.rpm);
  const maxRPM    = Math.max(...rpms);
  const minRPM    = Math.min(...rpms);

  // Set 2d context and dimensions
  const canvasContainer = document.getElementById("graphSection");
  const canvasEl = document.getElementById("graphCanvas");
  const canvasCtx = canvasEl.getContext("2d");
  const width = canvasContainer.offsetWidth;
  const height = canvasContainer.offsetHeight;
  canvasEl.width = width;
  canvasEl.height = height;

  canvasCtx.clearRect(0, 0, width, height);

  // Set fill and create axis
  canvasCtx.fillStyle = "white";
  canvasCtx.fillRect(0, 0, width, height);

  const spacing = 16;
  const fontSize = 10;
  canvasCtx.lineWidth = 2;
  canvasCtx.strokeStyle = "grey";

  // Draw axis
  canvasCtx.beginPath();
  canvasCtx.moveTo(spacing, spacing);
  canvasCtx.lineTo(spacing, height - spacing);
  canvasCtx.lineTo(width - spacing, height - spacing);
  canvasCtx.stroke();

  canvasCtx.font = `${fontSize}px sans-serif`;
  canvasCtx.fillStyle = "grey";
  canvasCtx.fillText(maxRPM.toFixed() + "/" + maxVolume.toFixed(2),
    spacing - fontSize, spacing + fontSize);
  canvasCtx.fillText("rpm/vol",
    spacing - fontSize, height / 2 + fontSize);
  canvasCtx.fillText(minRPM.toFixed() + "/" + minVolume.toFixed(2),
    spacing - fontSize, height - spacing + fontSize);
  canvasCtx.fillText("sec",
    width / 2, height - spacing + fontSize);
  canvasCtx.fillText(audioBuffer.duration.toString(),
    width - spacing, height - spacing + fontSize);

  const noSamples = engineRampSound.buffer.length;

  // convert an index into an x-position
  const convX = function(i) {
    return spacing +
       (engineRampSound.blocks[i].sampleStart / noSamples) * (width - spacing * 2);
  }

  // Draw graph volume
  canvasCtx.beginPath();
  for (let i = 0; i < engineRampSound.blocks.length; i++) {
    const xPos = convX(i);
    const yPos = height -
      (spacing + (engineRampSound.blocks[i].volume - minVolume) / (maxVolume - minVolume ) * (height - spacing * 2));
    if (i === 0) {
      canvasCtx.moveTo(xPos, yPos);
    } else {
      canvasCtx.lineTo(xPos, yPos);
    }
  }
  canvasCtx.strokeStyle = "gray";
  canvasCtx.stroke();

  // Draw graph RPM
  canvasCtx.beginPath();
  for (let i = 0; i < engineRampSound.blocks.length; i++) {
    const xPos = convX(i);
    const yPos = height -
      (spacing + (engineRampSound.blocks[i].rpm - minRPM) / (maxRPM - minRPM ) * (height - spacing * 2));
    if (i === 0) {
      canvasCtx.moveTo(xPos, yPos);
    } else {
      canvasCtx.lineTo(xPos, yPos);
    }
  }
  canvasCtx.strokeStyle = "black";
  canvasCtx.stroke();

  canvasCtx.lineWidth = 1;
  // accel blocks
  for (let i = 0; i < engineRampSound.accelBlocks.length; i++) {
    if (!engineRampSound.accelBlocks[i]) {
      continue;
    }
    const xPos = convX(engineRampSound.accelBlocks[i]);
    canvasCtx.beginPath();
    canvasCtx.moveTo(xPos, height - spacing);
    canvasCtx.lineTo(xPos, height - spacing * 2);
    canvasCtx.strokeStyle = "red";
    canvasCtx.stroke();
  }

  // deccel blocks
  for (let i = 0; i < engineRampSound.deccelBlocks.length; i++) {
    if (!engineRampSound.deccelBlocks[i]) {
      continue;
    }
    const xPos = convX(engineRampSound.deccelBlocks[i]);
    canvasCtx.beginPath();
    canvasCtx.moveTo(xPos, height - spacing);
    canvasCtx.lineTo(xPos, height - spacing * 2);
    canvasCtx.strokeStyle = "blue";
    canvasCtx.stroke();
  }
}


function analyzeFile(file)
{
  const noCylinders = document.getElementById("inputCylinders2").valueAsNumber;
	let audioBuffer = null;
	let reader = new FileReader();
	reader.onload = function(){
    context.decodeAudioData(reader.result, function(buffer) {
      analyzeAudio(buffer, noCylinders);
		}, function(){
			// error
		});
	}
	reader.readAsArrayBuffer(file);	
}


</script>

<style>
	body {
    font-family: arial;
	}
  legend {
    background-color: #000;
    color: #fff;
    padding: 3px 6px;
  }
  input {
    margin: 0.4rem;
  }
  fieldset {
    width: fit-content;
	  background-color: #eee;
  }
</style>

</head>

<body>
  <fieldset>
    <legend>Audio test</legend>
    <label for="input_file">Input file:</label>
    <input id="input_file" type="file" accept="*.wav" onchange="processFile(event)"/>
    <br />
    <audio id="audio_control" controls>
      <source id="audio_source" src="" type="audio/wav"/>
      <a id="audio_download" href="">Download audio</a>
    </audio>
  </fieldset>
  <br />

  <fieldset>
    <legend>Analyze engine sound</legend>
    Analyzes the given engine sound and outputs the rpm and relative volume. <br />
    <label for="input_file2">Input file:</label>
    <input id="input_file2"
        type="file"
        accept="*.wav"
        onchange="document.getElementById('inputAnalyze').disabled = false"/>
    <label for="inputCylinders2">Cylinders</label>
    <input id="inputCylinders2" type="number" min="1" max="12" value="10"/>
    <br />
    <input type="button" id="inputAnalyze"
        onclick="analyzeFile(document.getElementById('input_file2').files[0])"
        disabled
        value="Analyze"/>
    <br />
    <section
      id="graphSection"
      style="width: 30vw; height: 10vw;">
      <canvas id="graphCanvas" />
    </section>

    <label for="inputCylinders3">Cylinders</label>
    <input id="inputCylinders3" type="number" min="1" max="12" value="10"/>
    <br />
    <input type="button" id="inputSynthesize"
        onclick="synthesizeFile()"
        disabled
        value="Synthesize"/>
    <br />
  </fieldset>

  <small>
    Ralf Engels for <a href="https://github.com/TheDIYGuy999/Rc_Engine_Sound_ESP32">ESP32 RC Engine Sound & Light Controller</a>
  </small>

</body>
</html>
