<head>
<script>
"use strict";

// note: the surprising behaviour of the AudioContext.
// The reported sample rate is not the one from the file.
// See: https://stackoverflow.com/questions/34201957/why-are-decodeaudiodata-results-different-on-different-os
window.AudioContext = window.AudioContext || window.webkitAudioContext;
var context = new AudioContext();

/** Decodes a .h file and returns a buffer.
 *
 *  @returns An array with sample rate and the buffer data.
 */
function headerToArray(headerText) {

  const headerLines = headerText.split("\n");

  // -- find the sample rate:
  const srRe = /samplerate\s*=\s*(\d+)\s*;/i;
  let sampleRate = 22050;
  for (let i = 0; i < headerLines.length; i++) {
    let results = srRe.exec(headerLines[i]);
    if (results !== null) {
      sampleRate = parseInt(sampleRate)
      break;
    }
  }

  // -- find the samples (we assume it_s a line with commas
  let buffer = [];
  for (let i = 0; i < headerLines.length; i++) {
    let numbers = headerLines[i].split(",");
    if (numbers.length > 1) {
      // ignore everything after the last comma
      // might be a comment or a closing }
      for (let j = 0; j < numbers.length - 1; j++) {
          buffer.push(parseInt(numbers[j]) / 128.0);
      }
    }
  }

  return [sampleRate, buffer];
}


/** Converts the given text (header/include) file to a wav array.
 *
 *  @param repeats: The number of times the audio sample is
 *     repeated (put one after another).
 *  @returns An Int8Array with the wav data.
 */
function toWav(buffer, sampleRate, repeats=1) {

  const bytesNo = 1;  // number of bytes per sample
  const channels = 1;
  const samplesNo = buffer.length * repeats;
  const fileLength = samplesNo * bytesNo + 44;
  
  const buf = new ArrayBuffer(fileLength);
  const view = new DataView(buf, 0)

  // -- RIFF section
  view.setUint8(0, "R".charCodeAt(0));
  view.setUint8(1, "I".charCodeAt(0));
  view.setUint8(2, "F".charCodeAt(0));
  view.setUint8(3, "F".charCodeAt(0));
  view.setUint32(4, fileLength - 8, true)

  // -- format section
  view.setUint8(8, "W".charCodeAt(0));
  view.setUint8(9, "A".charCodeAt(0));
  view.setUint8(10, "V".charCodeAt(0));
  view.setUint8(11, "E".charCodeAt(0));

  view.setUint8(12, "f".charCodeAt(0));
  view.setUint8(13, "m".charCodeAt(0));
  view.setUint8(14, "t".charCodeAt(0));
  view.setUint8(15, " ".charCodeAt(0));

  view.setUint32(16, 16, true); // format section length
  view.setUint16(20, 1, true);  // format type (PCM)
  view.setUint16(22, channels, true); // format type (PCM)
  view.setUint32(24, sampleRate, true);

  const bitRate = bytesNo * channels * sampleRate;
  view.setUint32(28, bitRate, true);
  view.setUint16(32, bytesNo * channels, true);
  view.setUint16(34, bytesNo * 8, true);
  
  // -- data section
  view.setUint8(36, "d".charCodeAt(0));
  view.setUint8(37, "a".charCodeAt(0));
  view.setUint8(38, "t".charCodeAt(0));
  view.setUint8(39, "a".charCodeAt(0));

  const dataSectionLength = bytesNo * samplesNo;
  view.setUint32(40, dataSectionLength, true); // data section length
  let pos = 44;
  for (let j = 0; j < repeats; j++) {
    for (let i = 0; i < buffer.length; i++) {
      if (bytesNo == 1) {
        view.setUint8(pos, Math.round(buffer[i] * (1 << 7) + (1 << 7)));
        pos++;
      } else if (bytesNo == 2) {
        view.setUint16(pos, Math.round(buffer[i] * (1 << 15)), true);
        pos+=2;
      } else if (bytesNo == 4) {
        view.setUint32(pos, Math.round(buffer[i] * (1 << 31)), true);
        pos+=4;
      }
    }
  }

  return new Uint8Array(buf);
}


/** Starts downloading and then converting the given file.
 */
function newFileSelected(event)
{
  let fr = new FileReader();
  // fr.inputFileName = event.target.files[0];
  fr.onload = headerFileLoaded;  // onload fires after reading is complete
  fr.readAsText(event.target.files[0]);
}

function sqr(x) { return x * x; }

/** Returns an array with the normal distribution.
 */
function normDistribution(omega) {

  const halfWidth = omega * 2;
  const width = omega * 4 + 1;

  let buffer = new Float32Array(width);
  for (let i = 0; i < width; i++ ) {
    buffer[i] = (1.0 / Math.sqrt(2.0 * Math.PI * sqr(omega))) *
      Math.exp(-0.5 * sqr((i - halfWidth) / omega))
  }

  return buffer;
}


/** Applys a convolution low pass filter to the input buffer.
 *
 *  @param bufferIn An array with the audio samples.
 *  @param omega The width of the norm distribution used as filter.
 */
function filterLowpass(bufferIn, omega=5) {
  const filter = normDistribution(omega)

  let bufferOut = new Float32Array(bufferIn.length);
  for (let i = 0; i < bufferOut.length; i++) {
    bufferOut[i] = 0.0;
  }

  for (let i = 0; i < bufferIn.length; i++) {
    for (let j = 0; j < filter.length; j++) {
      let iI = i + j - Math.ceil(filter.length / 2);
      if (iI < 0) {
        iI = 0;
      } if (iI >= bufferIn.length) {
        iI = bufferIn.length - 1;
      }
      bufferOut[i] += bufferIn[iI] * filter[j];
    }
  }

  return bufferOut;
}


/** Returns an array of the positions in the input buffer
 *  where the values go from negative to positive.
 *
 *  @param bufferIn An array with the audio samples.
 */
function zeroCrossings(bufferIn) {
  let positions = [0];
  for (let i = 1; i < bufferIn.length; i++) {
    if (bufferIn[i - 1] < 0 && bufferIn[i] >= 0) {
      positions.push(i);
    }
  }
  positions.push(bufferIn.length - 1);

  return positions;
}


/** Cleans up the positions values by removing
 *  ones that are smaller than the minimum value.
 *
 *  Keeps the first and the last position.
 *
 *  @param positionsIn An array of positions. Sorted ascending. Must have at least one position
 *  @param minDist The minimum difference between the positions
 */
function cleanUpPositions(positionsIn, minDist) {
  let positionsOut = [positionsIn[0]];

  for (let i = 1; i < positionsIn.length - 1; i++) {
    if (positionsIn[i] - positionsIn[i-1] >= minDist) {
      positionsOut.push(positionsIn[i]);
    }
  }

  positionsOut.push(positionsIn[positionsIn.length - 1])
  return positionsOut;
}


/** Keep only evere n-th position.
 *
 *  Keeps the first and the last position.
 *
 *  @param positionsIn An array of positions. Sorted ascending.
 *  @param nth
 */
function keepNthPositions(positionsIn, nth) {
  let positionsOut = [];

  for (let i = 0; i < positionsIn.length - 2; i += nth) {
    positionsOut.push(positionsIn[i]);
  }

  positionsOut.push(positionsIn[positionsIn.length - 1])
  return positionsOut;
}


/** Calculates the volume of the blocks.
 */
function calcVolumeBlock(positions, buffer) {
  let volumes = [];

  for (let i = 0; i < positions.length - 1; i++) {
    let minValue = 0;
    let maxValue = 0;
    for (let j = positions[i]; j < positions[i + 1]; j++) {
      maxValue = Math.max(maxValue, buffer[j]);
      minValue = Math.min(minValue, buffer[j]);
    }
    volumes.push(maxValue - minValue);
  }

  return volumes;
}


/** Calculates the rpms of the blocks.
 */
function calcRpmBlock(positions, samplerate) {
  let rpms = [];

  for (let i = 1; i < positions.length; i++) {
    const rpm = 60.0 * samplerate / (positions[i] - positions[i-1]);
    rpms.push(rpm);
  }

  return rpms;
}


function addBlock(buffer, positions, block, reverse, newBuffer) {
  if (block < 0) {
    block = 0;
  }
  if (block >= positions.length - 1) {
    block = positions.length - 2;
  }

  if (reverse) {
  for (let j = positions[block + 1] - 1; j >= positions[block]; j--) {
      newBuffer.push(buffer[j]);
    }
  } else {
    for (let j = positions[block]; j < positions[block + 1]; j++) {
      newBuffer.push(buffer[j]);
    }
  }
}

function processAudio(audioBuffer)
{
  // float 32 array (-1..1)
	let buffer = audioBuffer.getChannelData(0);
  const origSampleRate = audioBuffer.length / audioBuffer.duration;

  // -- convert to mono if not already
	if (audioBuffer.numberOfChannels > 1)
	{
		for(let c = 1; c < audioBuffer.numberOfChannels; c++)
		{
			const cb = audioBuffer.getChannelData(c);
			for(let i = 0; i < cp.length; i++)
				buffer[i] += cb[i];
		}
	}

  // buffer = filterLowpass(buffer);

  const positions = keepNthPositions(cleanUpPositions(zeroCrossings(filterLowpass(buffer, 5)), 100), 10);
  
  let diffs = [];
  for (let i = 0; i < positions.length - 1; i++) {
    diffs.push(positions[i+1] - positions[i]);
  }

  // new buffer by skipping every second position
  let newBuffer = [];
  /*
  for (let i = 0; i < positions.length - 1; i++) {
    addBlock(buffer, positions, i, false, newBuffer);
    addBlock(buffer, positions, i, false, newBuffer);
  }
  */
  for (let i = positions.length - 2; i >=0; i-=3) {
    addBlock(buffer, positions, i, false, newBuffer);
  }
  for (let j = 0; j < 10; j++) {
    for (let i = 1; i < 8; i++) {
      addBlock(buffer, positions, i, false, newBuffer);
      addBlock(buffer, positions, i, false, newBuffer);
      addBlock(buffer, positions, i, false, newBuffer);
    }
    for (let i = 7; i >=1; i--) {
      addBlock(buffer, positions, i, false, newBuffer);
      addBlock(buffer, positions, i, false, newBuffer);
      addBlock(buffer, positions, i, false, newBuffer);
    }
  }

  const blob = new Blob(
    [toWav(
        newBuffer,
        origSampleRate,
        1)],
    {type:'audio/wav'});
  const URLObject = window.webkitURL || window.URL;
  const url = URLObject.createObjectURL(blob);

  let audio_source = document.querySelector('#audio_source');
  audio_source.src = url;

  document.querySelector('#audio_download').href=url;

  let audio_control = document.querySelector('#audio_control');
  audio_control.pause();
  audio_control.load();
  audio_control.oncanplaythrough = audio_control.play();
}


function processFile(event)
{
	let audioBuffer = null;
	let reader = new FileReader();
	let file = event.target.files[0];
	reader.onload = function(){
    context.decodeAudioData(reader.result, function(buffer) {
      processAudio(buffer);
		}, function(){
			// error
		});
	}
	reader.readAsArrayBuffer(file);	
}


function analyzeAudio(audioBuffer, noCylinders)
{
  // float 32 array (-1..1)
	let buffer = audioBuffer.getChannelData(0);
  const origSampleRate = audioBuffer.length / audioBuffer.duration;

  // -- convert to mono if not already
	if (audioBuffer.numberOfChannels > 1)
	{
		for(let c = 1; c < audioBuffer.numberOfChannels; c++)
		{
			const cb = audioBuffer.getChannelData(c);
			for(let i = 0; i < cp.length; i++)
				buffer[i] += cb[i];
		}
	}

  const positions = keepNthPositions(
    cleanUpPositions(
      zeroCrossings(
        filterLowpass(buffer, 20)), 100), noCylinders);
  
  const volumes = calcVolumeBlock(positions, buffer);
  const maxVolume = Math.max(...volumes);
  const minVolume = Math.min(...volumes);
  const rpms = calcRpmBlock(positions, origSampleRate);
  const maxRPM = Math.max(...rpms);
  const minRPM = Math.min(...rpms);


  // Set 2d context and dimensions
  const canvasContainer = document.getElementById("graphSection");
  const canvasEl = document.getElementById("graphCanvas");
  const canvasCtx = canvasEl.getContext("2d");
  const width = canvasContainer.offsetWidth;
  const height = canvasContainer.offsetHeight;
  canvasEl.width = width;
  canvasEl.height = height;

  // Set fill and create axis
  canvasCtx.fillStyle = "white";
  canvasCtx.fillRect(0, 0, width, height);

  const spacing = width / 16;
  const fontSize = Math.floor(spacing / 2.5);
  canvasCtx.lineWidth = 2;
  canvasCtx.strokeStyle = "grey";

  // Draw axis
  canvasCtx.beginPath();
  canvasCtx.moveTo(spacing, spacing);
  canvasCtx.lineTo(spacing, height - spacing);
  canvasCtx.lineTo(width - spacing, height - spacing);
  canvasCtx.stroke();

  canvasCtx.font = `${fontSize}px sans-serif`;
  canvasCtx.fillStyle = "grey";
  canvasCtx.fillText(maxRPM.toFixed() + "/" + maxVolume.toFixed(2),
    spacing - fontSize, spacing + fontSize);
  canvasCtx.fillText("rpm/vol",
    spacing - fontSize, (height - spacing + fontSize) / 2);
  canvasCtx.fillText(minRPM.toFixed() + "/" + minVolume.toFixed(2),
    spacing - fontSize, height - spacing + fontSize);
  canvasCtx.fillText("sec",
    width / 2, height - spacing + fontSize);
  canvasCtx.fillText(audioBuffer.duration.toString(),
    width - spacing, height - spacing + fontSize);

  // Draw graph RPM
  canvasCtx.beginPath();
  for (let i = 0; i < rpms.length; i++) {
    const xPos = spacing + (i / rpms.length) * (width - spacing * 2);
    const yPos = height -
      (spacing + (rpms[i] - minRPM) / (maxRPM - minRPM ) * (height - spacing * 2));
    if (i === 0) {
      canvasCtx.moveTo(xPos, yPos);
    } else {
      canvasCtx.lineTo(xPos, yPos);
    }
  }
  canvasCtx.strokeStyle = "black";
  canvasCtx.stroke();

  // Draw graph volume
  canvasCtx.beginPath();
  for (let i = 0; i < volumes.length; i++) {
    const xPos = spacing + (i / volumes.length) * (width - spacing * 2);
    const yPos = height -
      (spacing + (volumes[i] - minVolume) / (maxVolume - minVolume ) * (height - spacing * 2));
    if (i === 0) {
      canvasCtx.moveTo(xPos, yPos);
    } else {
      canvasCtx.lineTo(xPos, yPos);
    }
  }
  canvasCtx.strokeStyle = "gray";
  canvasCtx.stroke();
}


function analyzeFile(file)
{
  const noCylinders = document.getElementById("inputCylinders2").valueAsNumber;
	let audioBuffer = null;
	let reader = new FileReader();
	reader.onload = function(){
    context.decodeAudioData(reader.result, function(buffer) {
      analyzeAudio(buffer, noCylinders);
		}, function(){
			// error
		});
	}
	reader.readAsArrayBuffer(file);	
}


</script>

<style>
	body {
    font-family: arial;
	}
  legend {
    background-color: #000;
    color: #fff;
    padding: 3px 6px;
  }
  input {
    margin: 0.4rem;
  }
  fieldset {
    width: fit-content;
	  background-color: #eee;
  }
</style>

</head>

<body>
  <fieldset>
    <legend>Audio test</legend>
    <label for="input_file">Input file:</label>
    <input id="input_file" type="file" accept="*.wav" onchange="processFile(event)"/>
    <br />
    <audio id="audio_control" controls>
      <source id="audio_source" src="" type="audio/wav"/>
      <a id="audio_download" href="">Download audio</a>
    </audio>
  </fieldset>
  <br />

  <fieldset>
    <legend>Analyze engine sound</legend>
    Analyzes the given engine sound and outputs the rpm and relative volume. <br />
    <label for="input_file2">Input file:</label>
    <input id="input_file2"
        type="file"
        accept="*.wav"
        onchange="document.getElementById('inputAnalyze').disabled = false"/>
    <br />
    <label for="inputCylinders2">Cylinders</label>
    <input id="inputCylinders2" type="number" min="1" max="12" value="10"/>
    <br />
    <input type="button" id="inputAnalyze"
        onclick="analyzeFile(document.getElementById('input_file2').files[0])"
        disabled
        value="Analyze"/>
    <br />
    <section
      id="graphSection"
      style="width: 30vw; height: 10vw;">
      <canvas id="graphCanvas" />
    </section>
  </fieldset>

  <small>
    Ralf Engels for <a href="https://github.com/TheDIYGuy999/Rc_Engine_Sound_ESP32">ESP32 RC Engine Sound & Light Controller</a>
  </small>

</body>
</html>
